<!DOCTYPE html>
<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
        <meta charset="UTF-8">
        <link rel="stylesheet" href="leaflet/leaflet.css" />
        <script src="leaflet/leaflet.js"></script>       
        <script src="../ethereum/web3js/web3-browserify.js"> /* Add web1.0 for ens support and isAddress; use web 0.2 (metamask) for the transactions */ </script>
    </head>

    <body>
        <h1>Proof of location on ethereum blockchain</h1>   
        
        <button onclick="SaveLocation()">Press here to determine location</button><br>  <!-- needs user interaction for geolocation to work -->      
        <div id="map" style="width:100%;height:200px" ></div> 
        <button onclick="SaveOnBlockchain()">Press here to save on blockchain</button><br>  <!-- needs user interaction for geolocation to work -->      
        <pre id="log" style="width:100%;height:200px"></pre>
        <script type="text/javascript">
        function log(str,...arguments) {        
            var logstr=arguments.toString();
            document.getElementById("log").innerHTML +=str+" "+logstr+"\n";
        }        
        
        function EtherscanLink(pref,link) {
           return '<a href="https://ropsten.etherscan.io/'+pref+"/"+link+'" target="_blank" >'+link+'</a>';           
        }
        
        // https://www.geodatasource.com/developers/javascript
        function distance(lat1, lon1, lat2, lon2) {
            if ((lat1 == lat2) && (lon1 == lon2)) {
                return 0;
            }
            else {
                var radlat1 = Math.PI * lat1/180;
                var radlat2 = Math.PI * lat2/180;
                var theta = lon1-lon2;
                var radtheta = Math.PI * theta/180;
                var dist = Math.sin(radlat1) * Math.sin(radlat2) + Math.cos(radlat1) * Math.cos(radlat2) * Math.cos(radtheta);
                if (dist > 1) {
                    dist = 1;
                }
                dist = Math.acos(dist);
                dist = dist * 180/Math.PI;
                dist = dist * 60 * 1.1515;
                dist = dist * 1.609344  // kilometers
                
                dist = Math.round(dist * 1000) // meters
                return dist;
            }
        }
        
         
        if (location.protocol != 'https:') // make sure we are on https, otherwise geolocation doesn't work        
            location.href = 'https:' + window.location.href.substring(window.location.protocol.length);        
        var map = L.map('map');
        var basemap = L.tileLayer('https://{s}.tile.osm.org/{z}/{x}/{y}.png', { attribution: 'Gerard Persoon'}); // load OpenStreetMap basemap
        basemap.addTo(map);

        const lathhs=52.0672
        const lonhhs=4.3245
        var latx4=0; 
        var lonx4=0;
        var dist=-1;
        var accounts=[];
                     
        ProofOfLocationABI=[{"constant": false,"inputs": [{"name": "distance","type": "int256"}],"name": "StoreDistanceHHS","outputs": [],"payable": false,"stateMutability": "nonpayable","type": "function"}];
             
        async function SaveOnBlockchain() {
            if (dist <  0) { log("No location yet");return;}  
            if (accounts.length == 0 || accounts[0].length < 10 ) { log("No ethereum address yet");return;}                          
            DistanceHHSaddress = await web3.eth.ens.getAddress('distancehhs.eth')
            log(`Contract is ${EtherscanLink("address",DistanceHHSaddress)}`);  
            const ProofOfLocationContract   = new web3.eth.Contract(ProofOfLocationABI, DistanceHHSaddress );
            
            log(`Storing distance to HHS: lat=${dist} (hex:${web3.utils.toHex(dist)}) `);
            x=await ProofOfLocationContract.methods.StoreProofOfLocation(dist).send({from: accounts[0]}).catch( (reason) => log(`Cannnot do transaction ${reason}`) );;                        
            log(`Transaction hash: ${EtherscanLink("tx",x.transactionHash)}`);
        }
             
        async function SaveLocation(){    
            log("Trying to get location");
            if (navigator.permissions) {
                var status=await navigator.permissions.query({name:'geolocation'});
                log (`Permission ${status.state}`);
                console.log(status.state);
            }
            
            if (!navigator.geolocation) { log('Geolocation not supported');return;}
            const location = await new Promise((resolve, reject) => navigator.geolocation.getCurrentPosition(  (x) => resolve(x), (y) => reject(y.message)) ).catch ( (reason) => log(`Geolocation error: ${reason}`) );
            if (!location) return;             
            dist=distance(lathhs,lonhhs,location.coords.latitude,location.coords.longitude);
            log(`Coordinates: lat=${location.coords.latitude}, lon=${location.coords.longitude} Distance to HHS=${dist}`);                                 
            var url=`https://geodata.nationaalgeoregister.nl/locatieserver/revgeo?lat=${location.coords.latitude}&lon=${location.coords.longitude}`;
            var latlng = new L.LatLng(location.coords.latitude, location.coords.longitude);        
            map.setView(latlng, 15)            
            var marker = L.marker(latlng).addTo(map);
            var response = await fetch (url);
            response = await response.json();
            log(`Physical location: ${response.response.docs[0].weergavenaam}`);        
       }
             
        async function asyncloaded() {
        console.log(ethereum)
        console.log(typeof ethereum)
            if (typeof ethereum !== 'undefined')
                await ethereum.enable().catch( (reason) => log('User rejected provider access',reason.message.substring(0,50)) )
            if (!Web3.givenProvider) { // Checking if web3 is accessible
                log("Web3 interface is not found. "+
                "Please install <a href='https://metamask.io'>Metamask</a>"+
                " or use <a href='https://www.opera.com/crypto'>Opera Crypto (android)");
                return; // stop this function
            }
            web3 = new Web3(Web3.givenProvider); // switch to version 1.0 when using metamask; provide web3 functions for Opera
            //typeof web3 === 'undefined' || web3 == 'undefined'
            log(`web3 is present: ${web3.version}`); // note: use ` (back quote)
            const network = await web3.eth.net.getId().catch( (reason) => log(`Cannnot find network ${reason}`) );
            if (typeof network === 'undefined' || network != 3) 
                { log("Please select Ropsten test network");return;}
            log("Ethereum network: Ropsten")
            accounts=await web3.eth.getAccounts();            
            log(`Ethereum address: ${EtherscanLink("address",accounts[0])}`);
            web3.transactionConfirmationBlocks = 1; // default 24
       }
       window.addEventListener('load', asyncloaded);       
        </script>        
    </body>
</html>




    
    
    